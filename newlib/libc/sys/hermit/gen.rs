#!/usr/bin/env -S cargo +nightly -Zscript

#![feature(pattern)]

use self::str_ext::StrExt;
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::str::FromStr;
use std::{env, fmt};

fn main() -> io::Result<()> {
    let action = env::args().nth(1).unwrap().parse::<Action>().unwrap();

    action.run()?;

    Ok(())
}

#[derive(Clone, Copy, Debug)]
enum Action {
    Forward,
    Stub,
}

impl Action {
    fn run(self) -> io::Result<()> {
        let stdin = io::stdin().lock();
        let stdin = BufReader::new(stdin);

        let stdout = io::stdout().lock();
        let mut stdout = BufWriter::new(stdout);

        let stderr = io::stderr().lock();
        let mut stderr = BufWriter::new(stderr);

        stderr.write_all(b"unmodified:\n")?;

        writeln!(stdout, "//! Generated by `./gen.rs {self} < in.c > out.c`")?;
        writeln!(stdout)?;
        writeln!(stdout, "#include <errno.h>")?;

        let mut last_empty = true;
        for line in stdin.lines() {
            let mut line = line?;

            if let Ok(f) = line.parse::<ItemFn>() {
                if !last_empty {
                    writeln!(&mut stdout)?;
                }
                match self {
                    Self::Forward => {
                        let forwarding = f.forward();
                        write!(&mut stdout, "{forwarding}")?;
                    }
                    Self::Stub => {
                        let stub = f.stub();
                        write!(&mut stdout, "{stub}")?;
                    }
                }
            } else {
                line.push('\n');
                stdout.write_all(line.as_bytes())?;

                if line != "\n" {
                    stderr.write_all(line.as_bytes())?;
                }
            }

            last_empty = line.trim_ascii().is_empty();
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct ParseActionError;

impl FromStr for Action {
    type Err = ParseActionError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "forward" => Ok(Self::Forward),
            "stub" => Ok(Self::Stub),
            _ => Err(ParseActionError),
        }
    }
}

impl Action {
    fn as_str(self) -> &'static str {
        match self {
            Action::Forward => "forward",
            Action::Stub => "stub",
        }
    }
}

impl fmt::Display for Action {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

#[derive(Clone, Debug)]
pub struct ItemFn {
    pub output: String,
    pub ident: String,
    pub inputs: Vec<TypeIdent>,
}

#[derive(Debug)]
pub struct ParseItemFnError;

impl FromStr for ItemFn {
    type Err = ParseItemFnError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (type_ident, s) = s.split_once('(').ok_or(ParseItemFnError)?;
        let TypeIdent { ty, ident } = type_ident.parse().map_err(|_| ParseItemFnError)?;

        let (s, semi) = s.rsplit_once(')').ok_or(ParseItemFnError)?;
        assert_eq!(semi, ";");

        let inputs = s
            .split(", ")
            .map(str::parse)
            .collect::<Result<_, _>>()
            .map_err(|_| ParseItemFnError)?;

        Ok(Self {
            output: ty,
            ident,
            inputs,
        })
    }
}

impl fmt::Display for ItemFn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        self.sig().fmt(f)?;
        f.write_char(';')?;

        Ok(())
    }
}

impl ItemFn {
    pub fn sig(&self) -> Sig<'_> {
        Sig { f: self }
    }
}

#[must_use]
pub struct Sig<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Sig<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let ItemFn {
            output,
            ident,
            inputs,
        } = self.f;

        let type_ident = TypeIdent {
            ty: output.clone(),
            ident: ident.clone(),
        };
        type_ident.fmt(f)?;

        f.write_char('(')?;

        let mut has_fields = false;
        for input in inputs {
            if has_fields {
                f.write_str(", ")?;
            }
            input.fmt(f)?;
            has_fields = true;
        }

        f.write_char(')')?;

        Ok(())
    }
}

impl ItemFn {
    fn call(&self) -> Call<'_> {
        Call { f: self }
    }
}

struct Call<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Call<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let ItemFn { ident, inputs, .. } = self.f;

        f.write_str(ident)?;

        f.write_char('(')?;
        let mut has_fields = false;
        for input in inputs {
            if has_fields {
                f.write_str(", ")?;
            }
            input.ident.fmt(f)?;
            has_fields = true;
        }
        f.write_char(')')?;

        Ok(())
    }
}

impl ItemFn {
    pub fn forward(&self) -> Forward<'_> {
        Forward { f: self }
    }

    pub fn stub(&self) -> Stub<'_> {
        Stub { f: self }
    }
}

#[must_use]
pub struct Forward<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Forward<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let sys_f = {
            let mut sys_f = self.f.clone();
            sys_f.ident.insert_str(0, "sys_");
            sys_f
        };

        let sig = self.f.sig();
        let sys_call = sys_f.call();
        writeln!(
            f,
            "{sys_f}

{sig} {{
    int ret = {sys_call};

    if (ret < 0) {{
        errno = -ret;
        ret = -1;
    }}

    return ret;
}}"
        )?;

        Ok(())
    }
}

#[must_use]
pub struct Stub<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Stub<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let sig = self.f.sig();
        writeln!(
            f,
            "{sig} {{
    errno = ENOSYS;
    return -1;
}}"
        )?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TypeIdent {
    pub ty: String,
    pub ident: String,
}

#[derive(Debug)]
pub struct ParseTypeIdentError;

impl FromStr for TypeIdent {
    type Err = ParseTypeIdentError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s == "void" {
            return Ok(Self {
                ty: "void".to_string(),
                ident: "".to_string(),
            })
        }

        let (ty, ident) = s
            .rsplit_once_inclusive([' ', '*'])
            .ok_or(ParseTypeIdentError)?;
        let ty = ty.trim_ascii_end();

        Ok(Self {
            ty: ty.to_string(),
            ident: ident.to_string(),
        })
    }
}

impl fmt::Display for TypeIdent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let Self { ty, ident } = self;

        f.write_str(ty)?;
        if ty != "void" && !ty.ends_with('*') {
            f.write_char(' ')?;
        }
        f.write_str(ident)?;

        Ok(())
    }
}

pub mod str_ext {
    use std::str::pattern::{Pattern, ReverseSearcher};

    pub trait StrExt {
        fn rsplit_once_inclusive<P: Pattern>(&self, delimiter: P) -> Option<(&str, &str)>
        where
            for<'a> P::Searcher<'a>: ReverseSearcher<'a>;
    }

    impl StrExt for str {
        fn rsplit_once_inclusive<P: Pattern>(&self, delimiter: P) -> Option<(&str, &str)>
        where
            for<'a> P::Searcher<'a>: ReverseSearcher<'a>,
        {
            let (_start, end) = delimiter.into_searcher(self).next_match_back()?;
            // SAFETY: `rfind` returned a valid index
            unsafe { Some((self.get_unchecked(..end), self.get_unchecked(end..))) }
        }
    }
}
