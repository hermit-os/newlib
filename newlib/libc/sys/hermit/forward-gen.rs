#!/usr/bin/env -S cargo +nightly -Zscript

#![feature(pattern)]

use self::str_ext::StrExt;
use std::fmt;
use std::io::{self, BufRead, BufReader, BufWriter, Write};
use std::str::FromStr;

fn main() -> io::Result<()> {
    let stdin = io::stdin().lock();
    let stdin = BufReader::new(stdin);

    let stdout = io::stdout().lock();
    let mut stdout = BufWriter::new(stdout);

    let stderr = io::stderr().lock();
    let mut stderr = BufWriter::new(stderr);

    stderr.write_all(b"unmodified:\n")?;

    stdout.write_all(b"//! Generated by `./forward-gen.rs < forward-in.c > forward.c`\n\n")?;

    for line in stdin.lines() {
        let mut line = line?;

        if let Ok(f) = line.parse::<ItemFn>() {
            let forwarding = f.forward();
            write!(&mut stdout, "\n{forwarding}")?;
        } else {
            line.push('\n');
            stdout.write_all(line.as_bytes())?;

            if line != "\n" {
                stderr.write_all(line.as_bytes())?;
            }
        }
    }

    Ok(())
}

#[derive(Clone, Debug)]
pub struct ItemFn {
    pub output: String,
    pub ident: String,
    pub inputs: Vec<TypeIdent>,
}

#[derive(Debug)]
pub struct ParseItemFnError;

impl FromStr for ItemFn {
    type Err = ParseItemFnError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (type_ident, s) = s.split_once('(').ok_or(ParseItemFnError)?;
        let TypeIdent { ty, ident } = type_ident.parse().map_err(|_| ParseItemFnError)?;

        let (s, semi) = s.rsplit_once(')').ok_or(ParseItemFnError)?;
        assert_eq!(semi, ";");

        let inputs = s
            .split(", ")
            .map(|fn_arg| fn_arg.parse())
            .collect::<Result<_, _>>()
            .map_err(|_| ParseItemFnError)?;

        Ok(Self {
            output: ty,
            ident,
            inputs,
        })
    }
}

impl fmt::Display for ItemFn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        self.sig().fmt(f)?;
        f.write_char(';')?;

        Ok(())
    }
}

impl ItemFn {
    pub fn sig(&self) -> Sig<'_> {
        Sig { f: self }
    }
}

pub struct Sig<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Sig<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let ItemFn {
            output,
            ident,
            inputs,
        } = self.f;

        let type_ident = TypeIdent {
            ty: output.clone(),
            ident: ident.clone(),
        };
        type_ident.fmt(f)?;

        f.write_char('(')?;

        let mut has_fields = false;
        for input in inputs {
            if has_fields {
                f.write_str(", ")?;
            }
            input.fmt(f)?;
            has_fields = true;
        }

        f.write_char(')')?;

        Ok(())
    }
}

impl ItemFn {
    fn call(&self) -> Call<'_> {
        Call { f: self }
    }
}

struct Call<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Call<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let ItemFn { ident, inputs, .. } = self.f;

        f.write_str(ident)?;

        f.write_char('(')?;
        let mut has_fields = false;
        for input in inputs {
            if has_fields {
                f.write_str(", ")?;
            }
            input.ident.fmt(f)?;
            has_fields = true;
        }
        f.write_char(')')?;

        Ok(())
    }
}

impl ItemFn {
    pub fn forward(&self) -> Forward<'_> {
        Forward { f: self }
    }
}

pub struct Forward<'a> {
    f: &'a ItemFn,
}

impl fmt::Display for Forward<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let sys_f = {
            let mut sys_f = self.f.clone();
            sys_f.ident.insert_str(0, "sys_");
            sys_f
        };

        let sig = self.f.sig();
        let call = sys_f.call();
        writeln!(
            f,
            "{sys_f}

{sig} {{
    return {call};
}}"
        )?;

        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TypeIdent {
    pub ty: String,
    pub ident: String,
}

#[derive(Debug)]
pub struct ParseTypeIdentError;

impl FromStr for TypeIdent {
    type Err = ParseTypeIdentError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (ty, ident) = s
            .rsplit_once_inclusive([' ', '*'])
            .ok_or(ParseTypeIdentError)?;
        let ty = ty.trim_ascii_end();

        Ok(Self {
            ty: ty.to_string(),
            ident: ident.to_string(),
        })
    }
}

impl fmt::Display for TypeIdent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;

        let Self { ty, ident } = self;

        f.write_str(ty)?;
        if !ty.ends_with('*') {
            f.write_char(' ')?;
        }
        f.write_str(ident)?;

        Ok(())
    }
}

pub mod str_ext {
    use std::str::pattern::{Pattern, ReverseSearcher};

    pub trait StrExt {
        fn rsplit_once_inclusive<P: Pattern>(&self, delimiter: P) -> Option<(&str, &str)>
        where
            for<'a> P::Searcher<'a>: ReverseSearcher<'a>;
    }

    impl StrExt for str {
        fn rsplit_once_inclusive<P: Pattern>(&self, delimiter: P) -> Option<(&str, &str)>
        where
            for<'a> P::Searcher<'a>: ReverseSearcher<'a>,
        {
            let (_start, end) = delimiter.into_searcher(self).next_match_back()?;
            // SAFETY: `rfind` returned a valid index
            unsafe { Some((self.get_unchecked(..end), self.get_unchecked(end..))) }
        }
    }
}
